# 多线程复习

**1.什么是进程?什么是线程?**

```
进程：是指一个内存中运行的应用程序
线程:是进程中的一个执行单元，负责当前进程中程序的执行，一个进程中至少有一个线程。一个进程中是可以有多个线程的，这个应用程序也可以称之为多线程程序。
```

**2.java中线程调度采用的是哪种调度方式?**

```
抢占式调度
```

**3.线程如何创建?步骤?**

```
第一种方式创建
  1.定义类继承Thread类
  2.重写run方法 线程任务
  3.开启线程  
	创建子类对象 调用start方法
第二种方式创建
  1.定义类实现Runnable接口
  2.重写run方法  线程任务 
  3.开启线程 
      创建实现类对象(线程任务对象)
      创建Thread类对象 将线程任务对象传入
      线程对象调用start方法
	
```

**4.为什么创建线程要继承Thread类?**

```
因为Thread类就是线程类,定义了线程的属性和功能,继承Thread类
就是线程类 就可以使用线程的属性和功能 比如start方法
```

**5.既然Thread类就是线程类,为什么不直接创建Thread类对象,而是要继承.**

```
直接创建Thread类对象也可以创建线程 
Thread t = new Thread();
t.start();
这没有问题 ,的确创建了线程,但是运行的是Thread类的run方法.
这个run方法中的内容不是我们想要的,所以我们继承Thread类
重写run方法 自己定义线程的任务
```

**6.为什么有了第一种方式,还要有第二种方式?**

```
1.第二种方式避免了单继承的局限性.因为一个类如果已经有了父类就不能使用第一种方式了
	因为java中 类是单继承的,但是可以使用第二种方式 因为接口是多实现
2.线程任务 与 线程 分离  解耦合.
3.更容易实现多个线程共享一个资源	
```

**7.sleep与wait的区别**

```
sleep是Thread类的静态方法
sleep是睡眠指定时间后自动醒来 继续执行
sleep可以在同步中 或者同步外使用,如果在同步中使用 线程遇到sleep睡眠 不释放锁对象
wait是Object类方法
wait是在对象监视器上等待 其他线程唤醒
wait必须在同步中使用 由对象监视器(锁对象)调用  当线程遇到wait进入到等待状态 会释放掉锁
其他线程 是可以获取锁 当被notify唤醒后需要再次获取锁
```

**8.join方法作用?**

```
join方法是让当前线程等待,调用方法的线程进行插队先执行,执行完毕后,在让当前线程执行.对其他线程没有任何影响
```

**9.什么时候会出现线程安全问题?**

```
多个线程同时操作一个资源,就有可能出现线程不安全,数据错误.
```

**10.如何保证线程安全**

```
使用同步或者使用lock锁
```

**11.线程的状态有哪几种?**

```
NEW(新建) 线程刚被创建，但是并未启动。还没调用start方法。

Runnable(可运行) 线程可以在java虚拟机中运行的状态，可能正在运行自己代码，也可能没有，这取决于操作系统处理器。

Blocked(锁阻塞) 当一个线程试图获取一个对象锁，而该对象锁被其他的线程持有，则该线程进入Blocked状态；当该线程持有锁时，该线程将变成Runnable状态。

Waiting(无限等待) 一个线程在等待另一个线程执行一个（唤醒）动作时，该线程进入Waiting状态。进入这个状态后是不能自动唤醒的，必须等待另一个线程调用notify或者notifyAll方法才能够唤醒。

Timed Waiting(计时等待) 同waiting状态，有几个方法有超时参数，调用他们将进入Timed Waiting状态。这一状态将一直保持到超时期满或者接收到唤醒通知。带有超时参数的常用方法有Thread.sleep 、Object.wait。

Teminated(被终止) 因为run方法正常退出而死亡，或者因为没有捕获的异常终止了run方法而死亡。

```

**12.JUC编程三大特性(了解 具体见第18天讲义)**

```
原子性
可见性
有序性
```

**13.CAS无锁机制是什么?什么是ABA问题?(了解,具体见讲义)**

```
CAS机制当中使用了3个基本操作数：一个当前内存值V、旧的预期值A、即将更新的值B,当且仅当预期值A和内存值V相同时,将内存值修改为B,如果不相等,cas失败,返回当前内存值V.
ABA问题
第一条线程获取到V位置的值  假设是 1
第二条线程获取到V位置的值  也是1
第一条线程cas成功 将值改为 0
第一条线程又cas成功 将值改回 1
这时第二条线程cas 发现值没变 还是1 cas成功   
实际上当第二条线程cas时 V位置的值已经从 1-0-1
这就是ABA问题 
如何解决 每次获取V位置的值时,带上一个版本号.这样就可以避免ABA问题 java中AtomicStampedReference这个类在cas时就是通过版本号来解决的
```

**14.volatile如何保证可见性?(具体见讲义)**

```
底层实现主要是通过汇编lock前缀指令,会锁住这块区域的缓存,并写回主内存.

1.会将当前处理器缓存的行数据立即写回系统内存

2.这个写回内存的操作导致CPU的缓存该内存地址的数值失效(MESI协议)

注意:volatile只能保证可见性,但是不能保证原子性,如果要保证原子性,请使用锁

```

**15.什么是CPU指令重排?CPU什么时候会指令重排?如何禁止重排?(了解)**

```
CPU可能会对没有依赖关系的语句进行重排,但是不会对有依赖关系的数据进行重排.
可以使用volatile进行禁止重排 
具体见讲义
```

**16.什么是DCL单例?DCL单例是否需要使用volatile关键字?(了解)**

```
具体见讲义
DCL单例:双检查锁机制  需要加volatile关键字
```

**17.常用的阻塞队列有哪些?举出3个(了解)**

```
- ArrayBlockingQueue：是一个用数组实现的有界阻塞队列，此队列按照先进先出（FIFO）的原则对元素进行排序。支持公平锁和非公平锁。【注：每一个线程在获取锁的时候可能都会排队等待，如果在等待时间上，先获取锁的线程的请求一定先被满足，那么这个锁就是公平的。反之，这个锁就是不公平的。公平的获取锁，也就是当前等待时间最长的线程先获取锁】
- LinkedBlockingQueue：一个由链表结构组成的有界队列，此队列的长度为Integer.MAX_VALUE。此队列按照先进先出的顺序进行排序。
- SynchronousQueue： 一个不存储元素的阻塞队列，每一个put操作必须等待take操作，否则不能添加元素。支持公平锁和非公平锁。

```

**18.ThreadPoolExecutor创建线程池的参数有哪些?(了解)**

```
public ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue<Runnable> workQueue,
                              ThreadFactory threadFactory,
                              RejectedExecutionHandler handler)
corePoolSize 核心线程数量，线程池维护线程的最少数量

maximumPoolSize 线程池维护线程的最大数量

keepAliveTime 线程池除核心线程外的其他线程的最长空闲时间，超过该时间的空闲线程会被销毁

unit keepAliveTime的单位，TimeUnit中的几个静态属性：NANOSECONDS、MICROSECONDS、MILLISECONDS、SECONDS

workQueue 线程池所使用的任务缓冲队列

threadFactory 线程工厂，用于创建线程，一般用默认的即可

handler 线程池对拒绝任务的处理策略

```

**19.线程池的执行流程?(了解)**

```
见讲义
```

