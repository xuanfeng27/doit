final
	最终修饰符 可以修饰 类 方法 变量
	修饰类   类不能被继承
	修饰方法 方法不能被重写
	修饰变量 只能赋值一次 不能2次赋值 是常量
	
	1.final修饰引用数据类型变量 变量的地址值不能改变 但是属性值可以变
	2.final修饰成员变量 不能使用默认值 创建对象之前赋值 
				     直接显示赋值 
					 所有构造方法中赋值
接口 
    接口是功能的集合 描述的是功能 接口中都是抽象方法(JDK1.8之前)
	定义格式 
		public interface 接口名{
			 抽象方法;
		}
	接口的使用 
		1.接口不能创建对象
		2.使用类实现接口  
		3.重写抽象方法 
		4.创建实现类对象 调用方法
		
		实现的动作类似继承 就是关键字不同 
		public class 类  implements 接口{
			  重写方法
		}
	接口的成员特点 
		 接口没有构造方法 
		 接口中的成员变量 被public static final修饰 是常量
		 接口中的成员方法 被public abstract修饰 
	
	接口的特点 
		类与类 单继承 
		类与接口 多实现
		接口与接口 多继承 
		类可以在继承一个类的同时 实现多个接口
		
	接口与抽象类的区别
		成员区别 
			 构造方法 
				 接口没有构造方法
				 抽象类有构造方法 给子类使用
			  成员变量 
				 接口没有变量 只有常量
				 抽象类既可以有变量 也可以有常量
			  成员方法 
				 接口中的方法都是抽象的 
				 抽象类中 既可以有抽象方法 也可以有具体的方法
		思想的区别
			抽象类描述的是一类事物的共性内容 
			接口描述的是功能
多态 
	多态的前提 
		 1.继承或者是实现关系 
		 2.需要有方法重写
	多态的格式 
		父类引用指向子类对象 
		具体类  变量 = new 子类对象();
		抽象类  变量 = new 子类对象();
		接口  变量 = new 实现类对象();
		
	 多态后访问的成员特点 
		成员变量  
			  编译时 到父类中找 如果有编译通过 没有报错
			  运行时  打印的父类成员变量的值
			  编译时  看左边
			  运行时  看左边 
		成员方法 
			 编译时 到父类中找 如果有编译通过 没有报错
			 运行时  子类重写后的方法 
			 
			 编译时 看左边 
			 运行时 看右边
		
		多态后 一切都是父类的表现形式 只有方法运行的子类重写后的方法.
		
	 向上转型 
		 多态本身就是向上转型 
		 Fu fz = new Zi();
	 向下转型 
		 向上转型后 不能访问子类特有功能
		 要想访问 需要向下转型
		 Zi zf = (Zi)fz;
			
		 需要注意 
			Fu fu = new Zu();
			Zi  zi = (Zi)fu; //抛运行时异常  ClassCastException 类型转换异常
			
	 instanceof关键字 
	 boolean b = 对象 instanceof 类型;
	 
	 if(对象 instanceof 类型){
		向下转型 避免出现类型转换异常
	 }
			
			
闭包与回调
闭包（closure）是一个可调用的对象，它记录了一些信息，这些信息来自于创建它的作用域。通过这个定义，可以看出内部类是面向对象的闭包
，因为它不仅包含外部类对象（创建内部类的作用域）的信息，还自动拥有一个指向此外部类对象的引用，在此作用域内，内部类有权操作所有的成员
，包括 private 成员。

在 Java 8 之前，内部类是实现闭包的唯一方式。
在 Java 8 中，我们可以使用 lambda 表达式来实现闭包行为，并且语法更加优雅和简洁.

			
			
				 
	
	
	
	
	
	
	
	
	
	
	
	